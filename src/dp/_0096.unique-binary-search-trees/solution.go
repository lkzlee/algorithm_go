package _0096_unique_binary_search_trees

/***
96. 不同的二叉搜索树
给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？

示例:

输入: 3
输出: 5
解释:
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
*/
func NumTrees(n int) int {
	//DP问题 dp[n] 表示1,2,3...n个节点组成的不同结构的二叉搜索树个数
	//dp[0]=1 代表空节点，空的二叉树
	//dp[1]=f(1) 代表1 节点为根节点的不通结构二叉树
	//dp[2]=f(1,2)+f(2,2) ,f(i,n)代表以i为根节点的二叉搜索树个数
	//对于1,2节点
	//f(1,2)=（左子树为空）dp[0]*dp[2-1]（右子树为1个节点的二叉树）
	//f(2,2)=（左子树为1个节点的二叉树） dp[2-1]*dp[2-2] （右子树为空）
	//对于1,2,3节点 dp[3]=f(1,3)+f(2,3)+f(3,3)
	//f(1,3)=（左子树为空）左子树为空dp[1-1]*dp[3-1]（右子树2，3节点）
	//f(2,3)=（左子树1节点）dp[2-1]*dp[3-2] （右子树3节点）
	//f(3,3)=(左子树1,2节点)dp[3-1]*dp[3-3] (右子树为空)

	//由此推出dp[n]=f(1,n)+f(2,n)+f(3,n)+...+f(n,n)
	//f(1,n)=dp[0]*dp[n-1]
	//f(2,n)=dp[1]*dp[n-2]
	//f(i,n)=dp[i-1]*dp[n-i]
	//f(n,n)=dp[n-1]*dp[0]

	if n <= 1 {
		return 1
	}
	dp := make([]int, n+1)
	dp[0] = 1
	dp[1] = 1
	for i := 2; i <= n; i++ {
		for j := 1; j <= i; j++ {
			dp[i] += dp[j-1] * dp[i-j]
		}
	}
	return dp[n]
}
